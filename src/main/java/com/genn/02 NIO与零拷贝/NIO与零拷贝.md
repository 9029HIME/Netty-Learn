# BIO

​	了解零拷贝前，先看看BIO的拷贝过程中，经历了几次**上下文切换**与**数据拷贝**。

​	1.读文件，先从**用户态切换到内核态**，通过OS调度，将硬盘空间/网卡缓冲区的数据用**DMA拷贝**到内核态的一个缓冲区A。

​	2.读文件，将内核态缓冲区A的数据用**CPU拷贝**到用户空间，同时**从内核态切换为用户态。**

​	3.Java代码对数据进行拷贝处理中...

​	4.写文件，将用户态空间的数据用**CPU拷贝**到内核态缓冲区B中，同时**从用户态切换为内核态**。

​	5.写文件，内核态缓冲区B的数据用**DMA拷贝**到硬盘空间/网卡缓冲区内。

​	6.**内核态切换为用户态。**

​	总结：如下图，经历了4次上下文切换，2次CPU拷贝，2次DMA拷贝。

​	![img](https://img-blog.csdnimg.cn/20181106215957129.gif)

![img](https://img-blog.csdnimg.cn/20181106220015103.gif)



# NIO与零拷贝

​	FileChannel提供了transferTo()方法，它是零拷贝的一个封装，底层调用了transferTo0()这个JNI，落实到Linux/Unix的sendfile()函数。

## Linux2.4前：

​	1.Java调用transferTo()，**用户态切换到内核态**，通过OS调度，将硬盘空间/网卡缓冲区的数据用**DMA拷贝**到内核态的一个缓冲区A。

​	2.通过OS调度，将缓冲区A的数据用**CPU拷贝**到内核态缓冲区B。

​	3.内核态缓冲区B的数据用**DMA拷贝**到硬盘空间/网卡缓冲区内。

​	4.**内核态切换回用户态**

​	总结：如下图，经历了2次上下文切换，1次CPU拷贝，2次DMA拷贝。

![img](https://img-blog.csdnimg.cn/20181106220039659.gif)

![img](https://img-blog.csdnimg.cn/20181106220058650.gif)

## Linux2.4及之后（需要底层硬件支持scatter-gather操作）

​	1.Java调用transferTo()，**用户态切换到内核态**，通过OS调度，将硬盘空间/网卡缓冲区的数据用**DMA拷贝**到内核态的一个缓冲区A。

​	2.内核态缓冲区A的数据用**DMA拷贝**到硬盘空间/网卡缓冲区内。

​	3.**内核态切换回用户态**。

​	总结：如下图，经历了2次上下文切换，2次DMA拷贝。

​	![img](https://img-blog.csdnimg.cn/20181106220122207.gif)

## Windows

​	由于OS的不同，Windows每一次transferTo()只能拷贝8M大小的数据，**TODO：具体的切换次数，拷贝次数未知。**

## 零拷贝总结

​	所谓零拷贝，即不将数据拷贝到JVM内存内，而是直接在内核态将文件进行拷贝。**因为数据不经JVM，所以Java代码无法对数据进行修改**。其真正的实现依赖于操作系统，并不在于JDK本身。

# NIO直接内存映射

​	直接内存映射：和映射到JVM的内存地址不同，直接内存映射是**将文件直接映射到内核空间的内存缓冲区，属于BIO与零拷贝的一个折中办法，底层落实到Linux/Unix的mmap()函数。**它返回一个address，用MappedByteBuffer记录起来，并暴露各种操作API。对文件的修改会直接操作内核空间里**缓冲区（和上面的缓冲区AB是一个概念）**的数据，这样能节省从内核缓冲区到JVM的双向拷贝。

![img](https://pic4.zhimg.com/80/v2-6c07ee008ab6c4e381e56ecf3cc3f09f_720w.jpg)

​	**不过要注意的是**，MappedByteBuffer申请的是堆外内存，不收Minor GC控制，需要用Full GC回收。

​	DirectByteBuffer是MappedByteBuffer的子类，他提供了一个clean()方法，可以手动回收。